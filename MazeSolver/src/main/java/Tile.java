import ecs100.UI;

import java.awt.*;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;

/**
 * Created by sanjay on 22/04/16.
 */
public class Tile {
    //The current coordinates
    int x,y;
    //I use this instead of Math.random() because it gives more control
    static Random r = new Random();
    //A list of the sides of this tile that have walls
    HashSet<Direction> closed = new HashSet<>(Direction.values());
    static Direction last;
    //Lets make this look cool
    static Color color;
    public Tile(int x, int y) {
        this.x = x;
        this.y = y;
    }

    /**
     * Pick a random wall and destroy it, then return the tile in that direction
     * @return a random tile
     */
    public Tile randomWall() {
        //Loop in each direction and work out if its in bounds
        /*
            Identical to the following:
            List<Direction> tiles = new ArrayList<>();
            for (Direction c: Direction.values() {
                if (this.getRelative(c).inBounds()) tiles.add(c);
            }
         */
        List<Direction> tiles = closed.stream().filter(c -> this.getRelative(c).inBounds()).collect(Collectors.toList());
        //There are no tiles that are possible
        if (tiles.isEmpty()) return null;
        //Pick a random direction from the list of directions that are available
        Direction d = tiles.get(r.nextInt(tiles.size()));
        //Remove the randomness, so that we sprial, (like the floor cleaner does)
        //if (last != null && tiles.contains(last)) d = last;
        //Get the tile in the chosed direction
        Tile t = getRelative(d);
        //Remove the wall between the two tiles
        closed.remove(d);
        //Same as above but for the new tile
        t.closed.remove(d.reversed());
        //Set the last direction to the new one
        last = d;
        //Return the new tile
        return t;
    }
    //check if we hit the bounds OR if we have visited a tile before
    public boolean inBounds() {
        return inBoundsReal() && !Main.instance.tiles.contains(this);
    }
    //check if we hit the bounds
    public boolean inBoundsReal() {
        return x > -1 && x < Main.width && y > -1 && y < Main.height;
    }
    //Generated by intellij, creates a unique hash for each coordinate
    @Override
    public int hashCode() {
        int result = x;
        result = 31 * result + y;
        return result;
    }
    //get the tile in a direction
    public Tile getRelative(Direction dir) {
        return new Tile(x+dir.x,y+dir.y);
    }
    //(for maze solving) get a tile that has already been placed in a direction
    public Tile getRelativeReal(Direction dir) {

        return Main.instance.tiles.stream().collect(Collectors.toList()).stream().filter(t -> t.equals(getRelative(dir))).findAny().get();
    }
    //Check if two tiles are equal by position not reference
    public boolean equals(Object other) {
        return other instanceof Tile && ((Tile) other).x == x && ((Tile) other).y == y;
    }
    //The size of a tile
    int size = 20;
    //Draw the walls that havent been destroyed
    public void draw() {
        int x = this.x*size;
        int y = this.y*size;
        UI.setColor(color);
        UI.fillRect(x,y,size,size);
        UI.setColor(Color.BLACK);
        for (Direction dir : closed) {
            if (dir.x == -1 && dir.y == 0) {
                UI.drawLine(x,y,x,y+size);
            }
            if (dir.x == 1 && dir.y == 0) {
                UI.drawLine(x+size,y,x+size,y+size);
            }
            if (dir.x == 0 && dir.y == -1) {
                UI.drawLine(x,y,x+size,y);
            }
            if (dir.x == 0 && dir.y == 1) {
                UI.drawLine(x,y+size,x+size,y+size);
            }
        }
    }
    //Show the path as we solve
    public void fill() {
        int x = this.x*size;
        int y = this.y*size;
        UI.setColor(Color.RED);
        UI.fillRect(x+3,y+3,size-6,size-6);
    }
    //Just a nice way to print out a tile
    @Override
    public String toString() {
        return "Tile{" +
                "y=" + y +
                ", x=" + x +
                '}';
    }
    //Check if a direction has an open wall
    public boolean isOpen(Direction d) {
        return getRelative(d).inBoundsReal() && !closed.contains(d) && !getRelativeReal(d).closed.contains(d.reversed());
    }
}
